# Qiskit 2.x Practice Exam I

1. Which **two** code fragments will generate a Pauli X operator?

A. 
```python
from qiskit.quantum_info import Pauli
Pauli('X')@Pauli('I')
```

B. 
```python
from qiskit.quantum_info import Pauli

Pauli([False],[True],3])
```

C. 
```python
from qiskit import QuantumCircuit
from qiskit.quantum_info import Pauli

qc = QuantumCircuit(1)
qc.x(0)
p = Pauli(qc)
```

D.
```python
from qiskit.quantum_info import Pauli
Pauli('Y').tensor(Pauli('Z'))
```

2. Which is the resulting SparsePauliOp?
```python
SparsePauliOp.from_sparse_list([("XY",(0,2),1)],num_qubits=4)
```

A. 
```python
SparsePauliOp(['XIYI'],
              coeffs=[1.+0.j])
```

B. 
```python
SparsePauliOp(['IIXY'],
              coeffs=[1.+0.j]) 
```

C.
```python
SparsePauliOp(['XYII'],
              coeffs=[1.+0.j])
```

D. 
```python
SparsePauliOp(['IYIX'],
              coeffs=[1.+0.j])
```

3. Given the following code fragment what is the probability that a measurement would result in a value of 1?

```python
from qiskit import QuantumCircuit
from qiskit.quantum_info import Statevector
from numpy import pi

qc = QuantumCircuit(1)
qc.rx(pi/2,0)
```
A. 0   
B. 0.146  
C. 0.5  
D. 0.853  
E. 1  

4. Which is the fragment of code which generates the following state qsphere plot?
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/Q4.png>

A. 
```python
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)
```

B.
```python
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)
qc.z(1)
```

C. 
```python
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)
qc.cx(0,1)
```

D. 
```python
from qiskit import QuantumCircuit
from qiskit.visualization import plot_state_city

qc = QuantumCircuit(2)
qc.h(0)
qc.x(1)
qc.cx(0,1)
qc.z(1)
```

5. Which is the bloch multisphere plot being generated by the following piece of code?

```python
from qiskit.visualization import plot_bloch_multivector

state = Statevector.from_label('0+')
plot_bloch_multivector(state)
```
A.
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/A5a.png>

B.
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/A5b.png>

C. 
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/A5c.png>

D.
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/A5d.png>

6. Which **two** of the following code fragments generate the circuit in the picture below?
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/Q6.png>

A. 
```python
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)
qc.measure_all()
qc.draw('mpl')
```

B. 
```python
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)
qc.measure()
qc.draw('mpl')
```

C. 
```python
from qiskit import QuantumCircuit

qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)
qc.measure_active()
qc.draw('mpl')
```

7. Given the piece of code below, which is the proper way to transpile the circuit using the pass manager for our backend?
```python 
from qiskit import QuantumCircuit
from qiskit.transpiler import generate_preset_pass_manager
from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService()
backend = service.least_busy()
qc = QuantumCircuit(2)
qc.h(0)
qc.cx(0,1)
```

A. 
```python 
pm = generate_preset_pass_manager()
qct = pm.transpile(qc,backend=backend)
``` 

B. 
```python 
pm = generate_preset_pass_manager()
qct = pm.run(qc,backend=backend)
``` 

C. 
```python 
pm = generate_preset_pass_manager(backend=backend)
qct = pm.run(qc)
``` 

D. 
```python 
pm = generate_preset_pass_manager(backend=backend)
qct = pm.transpile(qc)
```

8. Which one from the histograms below might be the ouput of this circuit?
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/Q8.png>

A.
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/A8a.png>

B. 
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/A8b.png>

C. 
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/A8c.png>

D. 
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/A8d.png>

9. Which is the circuit generated using the code below?
```python
from qiskit import QuantumCircuit,QuantumRegister,ClassicalRegister
from qiskit.circuit import Parameter

theta = Parameter('theta')

qr = QuantumRegister(3,'q')
cr = ClassicalRegister(3,'c')
qc = QuantumCircuit(qr,cr)
for i in range(1,3):
    qc.h(i-1)  
    qc.crx(i*theta,0,i)  
qc.barrier()
qc.measure(qr,cr)

qc.draw('mpl')
```

A. 
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/A9a.png>

B.
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/A9b.png>

C. 
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/A9c.png>

D. 
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/A9d.png>

10. Which **two** are **not** proper ways to run jobs inside a bacth?

A. 
```python
with Session(backend=backend, mode="Batch") as batch:
    sampler1 = SamplerV2() 
    sampler2 = SamplerV2() 
    job1 = sampler1.run([(qct1,[],16)])
    job2 = sampler2.run([(qct2,[],16)])
```

B. 
```python
batch = Batch(backend=backend)
sampler1 = SamplerV2(mode=batch) 
sampler2 = SamplerV2(mode=batch) 
job1 = sampler1.run([(qct1,[],16)])
job2 = sampler2.run([(qct2,[],16)])
```

C. 
```python
with Backend(backend=backend) as backend:
    sampler1 = SamplerV2() 
    sampler2 = SamplerV2() 
    job1 = sampler1.run([(qct1,[],16)])
    job2 = sampler2.run([(qct2,[],16)])
```

D. 
```python
batch = Batch(backend=backend)
sampler1 = SamplerV2(mode=backend) 
sampler2 = SamplerV2(mode=backend) 
job1 = sampler1.run([(qct1,[],16)])
job2 = sampler2.run([(qct2,[],16)])
```

11. Which is the proper way to stop a pending batch/session from accepting new jobs while completing the pending ones?  

A. 
```python
batch.close() 
```
B.
```python
batch.cancel()  
```
C.
```python
batch.stop()  
```
D.
```python
batch.close(complete_pending=True)  
```

12. What happens to jobs if a session is closed?  

A. A session cannot be closed until all jobs complete their execution.  
B. The session no longer accepts new jobs,and existing jobs are cancelled.  
C. The session no longer accepts new jobs, but existing jobs run to completion.   
D. It is not required to close a session. They automatically close when all jobs have been completed.  

13. Which are the right steps to run an sampler?  

A.  
- Service initialization & backend retrieval 
- Circuit construction  
- Observable definition  
- Transpilation  
- Observable transformation (applying the layout)  
- Primitive(s) construction  
- Execution and retrieval  

B. 
- Service initialization & backend retrieval  
- Circuit construction  
- Primitive(s) construction  
- Transpilation  
- Execution and retrieval  

C.  
- Service initialization & backend retrieval  
- Circuit construction  
- Observable definition  
- Observable transformation (applying the layout)  
- Transpilation  
- Primitive(s) construction  
- Execution and retrieval  

D.  
- Service initialization & backend retrieval  
- Circuit construction  
- Transpilation  
- Primitive(s) construction  
- Execution and retrieval  

14. Having the circuit in the image using two parameters, which is the proper way to pass the Sampler the values for those parameters?
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/Q14.png>

A.
```python
from qiskit_ibm_runtime import SamplerV2 
from numpy import pi

sampler = SamplerV2(mode = backend)
parms = [{beta:0,theta:pi},{beta:pi,theta:0},{beta:pi,theta:pi}]
job = sampler.run([(qct,parms)])
```

B.
```python
from qiskit_ibm_runtime import SamplerV2 
from numpy import pi

sampler = SamplerV2(mode = backend)
parms = [[0,pi,pi],[pi,0,pi]]
job = sampler.run([(qct,parms)])
```

C. 
```python
from qiskit_ibm_runtime import SamplerV2 
from numpy import pi

sampler = SamplerV2(mode = backend)
parms = {beta:[0,pi,pi],theta:[pi,0,pi]}
job = sampler.run([(qct,parms)])
```

D.
```python
from qiskit_ibm_runtime import SamplerV2 
from numpy import pi

sampler = SamplerV2(mode = backend)
parms = [beta:{0,pi,pi},theta:{pi,0,pi}}
job = sampler.run([(qct,parms)])
```

15. Having the circuit in the image using two parameters, which is the proper way to pass the Estimator the values for those parameters?
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/Q15.png>

A.
```python
from qiskit_ibm_runtime import EstimatorV2 
from numpy import pi

estimator = EstimatorV2(mode = backend)
parms = [{beta:0,theta:pi},{beta:pi,theta:0},{beta:pi,theta:pi}]
job = estimator.run([(qct,observables,parms)])
```

B. 
```python
from qiskit_ibm_runtime import EstimatorV2 
from numpy import pi

estimator = EstimatorV2(mode = backend)
parms = {beta:[0,pi,pi],theta:[pi,0,pi]}
job = estimator.run([(qct,observables,parms)])
```

C.
```python
from qiskit_ibm_runtime import EstimatorV2 
from numpy import pi

estimator = EstimatorV2(mode = backend)
parms = [[0,pi,pi],[pi,0,pi]]
job = estimator.run([(qct,observables,parms)])
```

D.
```python
from qiskit_ibm_runtime import EstimatorV2 
from numpy import pi

estimator = EstimatorV2(mode = backend)
parms = [beta:{0,pi,pi},theta:{pi,0,pi}}
job = estimator.run([(qct,parms,observables)])
```

16. Which of the following options corresponds to a broadcasting rule in Qiskit Runtime primitives as used by the Primitive Unified Block (PUB)?  
   
A. A dimension is compatible for broadcasting if it is either equal in size or has size one.  
B. Every dimension must be a multiple of $2^n$.  
C. Each dimension must have the same length.  
D. Dimensions that are not provided are assumed to be zero-sized.  

17. Which **two** outputs are possible when executing the code below on the circuit shown in the image?
<img src=https://github.com/gnietof/QuantumTests/blob/main/exam1/images/Q17.png>

```python
from qiskit_ibm_runtime import SamplerV2 
from numpy import pi

parms = [0,pi]
sampler = SamplerV2(mode = backend)
job = sampler.run([(qc,parms)],shots=1024)
```

A. 
```python
job.result()[0].data.c[0].get_counts()
{'11': 499, '00': 525}
```

B. 
```python
job.result()[0].data.c[1].get_counts()
{'00': 505, '01': 519}
```

C. 
```python
job.result()[0].data.c[2].get_counts()
{'11': 499, '00': 525}
```

D.  
```python
job.result()[0].data.c.get_counts()
{'11': 519, '00': 505, '01': 506, '10': 518}
```

18. Which is the way to retrieve jobs which have been executed in a batch having id BATCH?

A. 
```python
from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService()
batch = Batch.from_id(service,BATCH)
jobs = batch.jobs()
```

B. 
```python
from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService()
batch = Batch.from_id(BATCH, service)
jobs = batch.jobs()
```

C. 
```python
from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService()
jobs = service.jobs(session_id=BATCH)
```

D. 
```python
from qiskit_ibm_runtime import QiskitRuntimeService

service = QiskitRuntimeService()
jobs = service.jobs(batch_id=BATCH)
jobs = batch.jobs()
```

19. Which would be the proper way to declare an array of ten five-bit precision signed integers in QASM3?  

A.  
```qasm
int[5][10] aa;
```

B.  
```qasm
arra(int[5], 10) aa;
```

C.  
```qasm
array[int[5], 10] aa;
```

D.  
```qasm
array[int[10], 5] aa;
```

20.	Which of these parameters should not be included in the header for a REST API request:  

A. IAM Key  
B. Bearer token  
C. Service CRN  
D. IBM API version  

<details>
  <summary>Show answer key</summary>  
  1. AC<br>  
  2. D<br>  
  3. C<br>
  4. D<br>
  5. C<br>
  6. AC<br>
  7. C<br>
  8. B<br>
  9. D<br>
 10. AD<br>
 11. A<br>
 12. C<br> 
 13. D<br> 
 14. C<br> 
 15. B<br>
 16. A<br>
 17. AD<br>
 18. C<br>
 19. C<br>
 20. A<br>
</details>
